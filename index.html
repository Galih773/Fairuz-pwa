<!DOCTYPE html>
<html lang="id" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyclone Separator Pro - CFD & Design Tool</title>
    <meta name="description" content="Cyclone Separator Pro untuk simulasi desain cyclone separator, analisis efisiensi, dan visualisasi 3D.">
    <meta name="theme-color" content="#0f172a">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Cyclone Pro">
    <link rel="manifest" href="./manifest.webmanifest">
    <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png">
    <link rel="apple-touch-icon" href="./icons/icon-192.png">
    <link rel="stylesheet" href="./assets/tailwind.css">
    <link rel="preload" href="./vendor/three.min.js" as="script">
    <link rel="preload" href="./vendor/OrbitControls.js" as="script">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; transition: background-color 0.3s, color 0.3s; }
        .glass-panel { backdrop-filter: blur(12px); }
        
        /* 3D Container responsive styling */
        #three-container { width: 100%; height: 100%; position: absolute; inset: 0; }
        .canvas-wrapper { position: relative; width: 100%; min-height: 50vh; flex-grow: 1; border-radius: 1rem; overflow: hidden; }
        @media (min-width: 1024px) { .canvas-wrapper { min-height: 600px; } }
        
        html.dark .canvas-wrapper { background: linear-gradient(135deg, #1e293b 0%, #020617 100%); box-shadow: inset 0 0 100px rgba(0,0,0,0.8); }
        html:not(.dark) .canvas-wrapper { background: linear-gradient(135deg, #f1f5f9 0%, #cbd5e1 100%); box-shadow: inset 0 0 50px rgba(0,0,0,0.1); }
        
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .input-group { display: flex; flex-direction: column; gap: 0.25rem; }
        .input-label { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #475569; }
        html.dark .input-label { color: #cbd5e1; }
        .custom-input { width: 100%; padding: 0.5rem; border-radius: 0.5rem; font-size: 0.875rem; border: 1px solid #cbd5e1; background-color: #f8fafc; transition: all 0.2s; outline: none;}
        html.dark .custom-input { border-color: #334155; background-color: #0f172a; color: white;}
        .custom-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); }
        .custom-input:disabled { opacity: 0.6; cursor: not-allowed; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        html.dark ::-webkit-scrollbar-thumb { background: #475569; }

        /* Header responsiveness fallback (tailwind.css in this project lacks sm:flex/sm:hidden) */
        .header-actions-desktop { display: flex; }
        .header-actions-mobile { display: none; }
        .mobile-only-layer { display: none !important; }
        @media (max-width: 767px) {
            .header-actions-desktop { display: none; }
            .header-actions-mobile { display: flex; }
            .mobile-only-layer { display: block !important; }
            .mobile-drawer-backdrop {
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.2s ease;
            }
            .mobile-drawer-backdrop.is-open {
                opacity: 1;
                pointer-events: auto;
            }
            .mobile-drawer-panel {
                top: 0;
                right: 0;
                bottom: 0;
                width: min(84vw, 320px);
                border-radius: 0;
                border-left-width: 1px;
                border-left-color: #e2e8f0;
                transform: translateX(100%);
                transition: transform 0.25s ease;
                padding-top: 72px;
            }
            html.dark .mobile-drawer-panel { border-left-color: #334155; }
            .mobile-drawer-panel.is-open { transform: translateX(0); }
            body.drawer-open { overflow: hidden; }
        }

        .mobile-drawer-actions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .mobile-drawer-action {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 0.875rem;
            border-radius: 0.75rem;
            font-size: 0.95rem;
            font-weight: 700;
            border: 1px solid transparent;
            transition: background-color 0.2s ease, color 0.2s ease, transform 0.15s ease;
        }
        .mobile-drawer-action:active { transform: scale(0.98); }
        .mobile-drawer-action-left {
            display: inline-flex;
            align-items: center;
            gap: 0.65rem;
        }
        .mobile-drawer-icon {
            width: 1.5rem;
            height: 1.5rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.45rem;
            flex-shrink: 0;
        }
        .mobile-drawer-action-install {
            background: #2563eb;
            color: #ffffff;
            border-color: #2563eb;
        }
        .mobile-drawer-action-install:hover { background: #1d4ed8; }
        .mobile-drawer-action-install .mobile-drawer-icon {
            background: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }
        .mobile-drawer-action-history {
            background: #e2e8f0;
            color: #1e293b;
            border-color: #cbd5e1;
        }
        .mobile-drawer-action-history:hover { background: #cbd5e1; }
        .mobile-drawer-action-history .mobile-drawer-icon {
            background: #cbd5e1;
            color: #334155;
        }
        html.dark .mobile-drawer-action-history {
            background: #1e293b;
            color: #e2e8f0;
            border-color: #334155;
        }
        html.dark .mobile-drawer-action-history:hover { background: #334155; }
        html.dark .mobile-drawer-action-history .mobile-drawer-icon {
            background: #334155;
            color: #e2e8f0;
        }
        .mobile-drawer-count {
            font-size: 0.85rem;
            font-weight: 700;
            color: #475569;
        }
        html.dark .mobile-drawer-count { color: #cbd5e1; }
    </style>
</head>
<body class="min-h-screen flex flex-col bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-slate-100">
    
    <!-- Top Header (Sticky) -->
    <header class="sticky top-0 z-40 w-full flex-shrink-0 flex items-center justify-between px-4 md:px-6 py-3 border-b border-slate-300 dark:border-slate-800 bg-white/90 dark:bg-slate-900/90 backdrop-blur-md shadow-sm">
        <div>
            <h1 class="text-lg md:text-xl font-extrabold tracking-tight flex items-center gap-2">
                <svg aria-hidden="true" class="w-6 h-6 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                <span class="text-blue-600 dark:text-blue-500">Cyclone</span> <span class="hidden sm:inline">Pro</span>
            </h1>
        </div>
        <div class="flex items-center gap-2 md:gap-3">
            <div class="header-actions-desktop items-center gap-2 md:gap-3">
                <button id="install-app-btn" data-install-app class="inline-flex items-center gap-1.5 px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-xs md:text-sm font-semibold transition-colors">
                    Install / Download
                </button>
                <button onclick="toggleHistoryModal()" class="flex items-center gap-1.5 px-3 py-1.5 bg-slate-100 hover:bg-slate-200 dark:bg-slate-800 dark:hover:bg-slate-700 rounded-lg text-xs md:text-sm font-semibold transition-colors border border-slate-200 dark:border-slate-700">
                    <svg aria-hidden="true" class="w-4 h-4 hidden sm:block" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    History (<span data-history-count>0</span>)
                </button>
            </div>
            <button onclick="toggleTheme()" aria-label="Ganti tema terang atau gelap" class="p-1.5 bg-slate-200 dark:bg-slate-800 hover:bg-slate-300 dark:hover:bg-slate-700 rounded-lg transition-colors">
                <svg aria-hidden="true" id="icon-sun" class="w-5 h-5 hidden dark:block text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                <svg aria-hidden="true" id="icon-moon" class="w-5 h-5 block dark:hidden text-slate-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
            </button>
            <span id="storage-status" class="hidden lg:inline-flex px-2.5 py-1 text-xs font-semibold rounded-md border border-slate-200 dark:border-slate-700 bg-slate-100 dark:bg-slate-800 text-amber-700 dark:text-amber-400">Storage: standar browser</span>
            <div class="header-actions-mobile items-center gap-2">
                <button id="mobile-menu-btn" onclick="toggleMobileActionMenu()" aria-label="Buka menu aksi" aria-expanded="false" class="p-2 bg-slate-200 dark:bg-slate-800 hover:bg-slate-300 dark:hover:bg-slate-700 rounded-lg transition-colors">
                    <svg aria-hidden="true" class="w-5 h-5 text-slate-700 dark:text-slate-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
            </div>
        </div>
    </header>

    <div id="mobile-action-backdrop" class="mobile-only-layer mobile-drawer-backdrop fixed inset-0 z-40 bg-slate-900/50" onclick="toggleMobileActionMenu(false)"></div>
    <div id="mobile-action-menu" class="mobile-only-layer mobile-drawer-panel fixed z-50 bg-white dark:bg-slate-900 shadow-2xl p-4" aria-hidden="true">
        <div class="flex items-center justify-between mb-3">
            <p class="text-sm font-bold text-slate-700 dark:text-slate-200">Menu Cepat</p>
            <button type="button" onclick="toggleMobileActionMenu(false)" aria-label="Tutup menu aksi" class="p-2 rounded-lg bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">
                <svg aria-hidden="true" class="w-4 h-4 text-slate-700 dark:text-slate-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="mobile-drawer-actions">
            <button id="install-app-btn-mobile" data-install-app type="button" class="mobile-drawer-action mobile-drawer-action-install">
                <span class="mobile-drawer-action-left">
                    <span class="mobile-drawer-icon">
                        <svg aria-hidden="true" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v2a2 2 0 002 2h12a2 2 0 002-2v-2M7 10l5 5m0 0l5-5m-5 5V4"></path></svg>
                    </span>
                    <span>Install / Download</span>
                </span>
                <svg aria-hidden="true" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            </button>
            <button type="button" onclick="openHistoryFromMobileMenu()" class="mobile-drawer-action mobile-drawer-action-history">
                <span class="mobile-drawer-action-left">
                    <span class="mobile-drawer-icon">
                        <svg aria-hidden="true" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    </span>
                    <span>History</span>
                </span>
                <span class="mobile-drawer-count">(<span data-history-count>0</span>)</span>
            </button>
        </div>
    </div>

    <!-- Main Layout Container -->
    <div class="flex-grow flex flex-col md:flex-row w-full max-w-[1600px] mx-auto">
        
        <!-- Sidebar (Input Panel) -->
        <aside aria-label="Panel input parameter" class="w-full md:w-[350px] lg:w-[400px] flex-shrink-0 border-b md:border-b-0 md:border-r border-slate-200 dark:border-slate-800 bg-white dark:bg-slate-900/50 flex flex-col md:h-[calc(100vh-60px)] md:sticky md:top-[60px] overflow-y-auto">
            <!-- Tabs -->
            <div class="flex p-2 gap-1 border-b border-slate-200 dark:border-slate-800 shrink-0">
                <button onclick="setMode('standard')" id="tab-standard" class="flex-1 py-2 text-xs md:text-sm font-bold rounded-md bg-blue-100 dark:bg-blue-900/40 text-blue-700 dark:text-blue-400 transition-colors">Standar (Ratio)</button>
                <button onclick="setMode('manual')" id="tab-manual" class="flex-1 py-2 text-xs md:text-sm font-bold rounded-md bg-transparent text-slate-500 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors">Manual Input</button>
            </div>

            <!-- Scrollable Content -->
            <div class="flex-grow p-4 space-y-6">
                
                <!-- STANDAR MODE SECTION -->
                <div id="section-standard" class="space-y-4 block">
                    <div class="input-group">
                        <label class="input-label text-blue-600 dark:text-blue-400" for="std-type">Standar Desain</label>
                        <select id="std-type" class="custom-input" onchange="applyStandardRatios()">
                            <option value="lapple">Lapple (1951) - General Purpose</option>
                            <option value="stairmand_he">Stairmand (1951) - High Efficiency</option>
                            <option value="stairmand_ht">Stairmand (1951) - High Throughput</option>
                            <option value="swift_he">Swift (1969) - High Efficiency</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label class="input-label text-blue-600 dark:text-blue-400" for="std-fixed-var">Variabel Utama (Yang Ingin Diatur)</label>
                        <select id="std-fixed-var" class="custom-input" onchange="applyStandardRatios()">
                            <option value="D">Diameter Siklon D (m)</option>
                            <option value="a">Tinggi Inlet a (m)</option>
                            <option value="b">Lebar Inlet b (m)</option>
                            <option value="De">Diameter Outlet Gas De (m)</option>
                            <option value="S">Panjang Pipa Outlet S (m)</option>
                            <option value="h">Tinggi Total Silinder h (m)</option>
                            <option value="H">Tinggi Total Siklon H (m)</option>
                            <option value="B">Diameter Outlet Dust B (m)</option>
                        </select>
                        <p class="text-[11px] text-slate-600 dark:text-slate-300 mt-1">Variabel lain akan dihitung otomatis berdasarkan rasio standar yang dipilih.</p>
                    </div>
                </div>

                <!-- GEOMETRY INPUTS -->
                <div class="bg-slate-100 dark:bg-slate-800/50 p-3 rounded-xl border border-slate-200 dark:border-slate-700">
                    <h3 class="text-xs font-bold uppercase text-slate-500 dark:text-slate-400 mb-3 flex items-center gap-2">
                        <svg aria-hidden="true" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg> Geometri (m)
                    </h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group"><label class="input-label" for="geom-D">Dia. Siklon (D)</label><input type="number" id="geom-D" value="1.0" step="0.1" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="geom-h">Tinggi Silinder (h)</label><input type="number" id="geom-h" value="2.0" step="0.1" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="geom-a">Tinggi Inlet (a)</label><input type="number" id="geom-a" value="0.5" step="0.05" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="geom-b">Lebar Inlet (b)</label><input type="number" id="geom-b" value="0.25" step="0.05" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="geom-De">Dia. Gas Out (De)</label><input type="number" id="geom-De" value="0.5" step="0.1" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="geom-S">Pipa Vortex (S)</label><input type="number" id="geom-S" value="0.625" step="0.05" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="geom-H">Tinggi Total (H)</label><input type="number" id="geom-H" value="4.0" step="0.1" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="geom-B">Dia. Dust Out (B)</label><input type="number" id="geom-B" value="0.25" step="0.05" class="custom-input" oninput="triggerRecalc()"></div>
                    </div>
                </div>

                <!-- FISIKA & OPERASIONAL -->
                <div class="space-y-3">
                    <h3 class="text-xs font-bold uppercase text-slate-500 dark:text-slate-400 border-b border-slate-200 dark:border-slate-800 pb-1">Kondisi Operasional</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group"><label class="input-label" for="phys-Q">Laju Alir (m³/s)</label><input type="number" id="phys-Q" value="2.5" step="0.1" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="phys-T">Suhu Gas (K)</label><input type="number" id="phys-T" value="298" step="1" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="phys-RhoP">Rho Partikel (kg/m³)</label><input type="number" id="phys-RhoP" value="2000" step="50" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="phys-Dp">Dia. Partikel (µm)</label><input type="number" id="phys-Dp" value="10" step="1" class="custom-input text-emerald-600 dark:text-emerald-400 font-bold" oninput="triggerRecalc()"></div>
                        <div class="input-group"><label class="input-label" for="phys-Mu">Viskositas Gas (µG × 10⁻⁵)</label><input type="number" id="phys-Mu" value="1.81" step="0.01" class="custom-input" oninput="triggerRecalc()"></div>
                        <div class="input-group">
                            <label class="input-label" for="phys-K">Konstanta Inlet (K)</label>
                            <select id="phys-K" class="custom-input" onchange="triggerRecalc()">
                                <option value="16">16 (S&L Default)</option>
                                <option value="7.5">7.5 (Alternative)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <button onclick="saveToHistory()" class="w-full py-3 bg-emerald-600 hover:bg-emerald-700 text-white rounded-xl font-bold transition-colors shadow-md flex justify-center items-center gap-2">
                    <svg aria-hidden="true" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                    Simpan Perhitungan
                </button>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="exportBackup()" class="py-2 px-3 bg-slate-200 hover:bg-slate-300 dark:bg-slate-800 dark:hover:bg-slate-700 rounded-lg text-xs font-bold transition-colors border border-slate-300 dark:border-slate-700">Export Backup</button>
                    <label class="py-2 px-3 bg-blue-100 hover:bg-blue-200 dark:bg-blue-900/30 dark:hover:bg-blue-900/50 rounded-lg text-xs font-bold text-blue-700 dark:text-blue-400 transition-colors border border-blue-200 dark:border-blue-800 text-center cursor-pointer">
                        Import Backup
                        <input id="import-backup-input" type="file" accept="application/json" class="hidden" onchange="importBackupFromFile(event)">
                    </label>
                </div>
                <p class="text-[11px] text-slate-600 dark:text-slate-300">Backup dipakai untuk restore data saat browser di-reset atau pindah device.</p>
                <p id="storage-quota-note" class="text-[11px] text-slate-600 dark:text-slate-300">Pemakaian storage lokal: mengecek...</p>
            </div>
        </aside>

        <!-- Main Content (3D & Results) -->
        <main class="flex-grow flex flex-col p-4 md:p-6 min-w-0 gap-4">
            
            <!-- Result Cards (Responsive Grid) -->
            <div class="grid grid-cols-2 xl:grid-cols-4 gap-3 md:gap-4 flex-shrink-0">
                <div class="glass-panel p-3 md:p-4 rounded-xl border border-slate-200 dark:border-slate-800 bg-white/50 dark:bg-slate-900/50 shadow-sm border-t-4 border-t-blue-500 flex flex-col justify-between">
                    <div>
                        <p class="text-[11px] md:text-xs font-bold text-slate-600 dark:text-slate-300 uppercase">Total Efficiency η</p>
                        <h3 class="text-xl md:text-3xl font-black text-slate-800 dark:text-white mt-1" id="res-eff">0%</h3>
                    </div>
                    <div class="text-[11px] md:text-xs text-slate-600 dark:text-slate-300 mt-2 font-mono">Model: Leith & Licht</div>
                </div>
                <div class="glass-panel p-3 md:p-4 rounded-xl border border-slate-200 dark:border-slate-800 bg-white/50 dark:bg-slate-900/50 shadow-sm border-t-4 border-t-yellow-500 flex flex-col justify-between">
                    <div>
                        <p class="text-[11px] md:text-xs font-bold text-slate-600 dark:text-slate-300 uppercase">Cut Point (d50)</p>
                        <h3 class="text-xl md:text-3xl font-black text-slate-800 dark:text-white mt-1" id="res-d50">0 μm</h3>
                    </div>
                    <div class="text-[11px] md:text-xs text-slate-600 dark:text-slate-300 mt-2 font-mono">Model: Lapple</div>
                </div>
                <div class="glass-panel p-3 md:p-4 rounded-xl border border-slate-200 dark:border-slate-800 bg-white/50 dark:bg-slate-900/50 shadow-sm border-t-4 border-t-orange-500 flex flex-col justify-between">
                    <div>
                        <p class="text-[11px] md:text-xs font-bold text-slate-600 dark:text-slate-300 uppercase">Pressure Drop ΔP</p>
                        <h3 class="text-xl md:text-3xl font-black text-slate-800 dark:text-white mt-1" id="res-dp">0 Pa</h3>
                    </div>
                    <div class="mt-2 text-[11px] md:text-xs text-slate-600 dark:text-slate-300 flex flex-col gap-0.5 w-full bg-slate-100 dark:bg-slate-800/50 p-1.5 rounded">
                        <div class="flex justify-between"><span>Barth:</span> <span id="res-dp-barth" class="font-bold text-slate-700 dark:text-slate-300">0 Pa</span></div>
                        <div class="flex justify-between"><span>Strmd:</span> <span id="res-dp-stairmand" class="font-bold text-slate-700 dark:text-slate-300">0 Pa</span></div>
                    </div>
                </div>
                <div class="glass-panel p-3 md:p-4 rounded-xl border border-slate-200 dark:border-slate-800 bg-white/50 dark:bg-slate-900/50 shadow-sm border-t-4 border-t-emerald-500 flex flex-col justify-between">
                    <div>
                        <p class="text-[11px] md:text-xs font-bold text-slate-600 dark:text-slate-300 uppercase">Inlet Velocity (Vi)</p>
                        <h3 class="text-xl md:text-3xl font-black text-slate-800 dark:text-white mt-1" id="res-vi">0 m/s</h3>
                    </div>
                    <div class="text-[11px] md:text-xs text-slate-600 dark:text-slate-300 mt-2 font-mono">Kecepatan gas masuk</div>
                </div>
            </div>

            <!-- 3D Container -->
            <div class="canvas-wrapper">
                <div id="three-container" role="img" aria-label="Visualisasi 3D cyclone separator"></div>
                
                <!-- Controls Overlay -->
                <div class="absolute bottom-2 md:bottom-4 left-2 right-2 md:left-4 md:right-4 flex flex-col sm:flex-row justify-between items-start sm:items-end gap-2 pointer-events-none">
                    <div class="bg-black/50 backdrop-blur-md px-2 md:px-3 py-1.5 md:py-2 rounded-lg text-white/80 text-[11px] md:text-xs font-mono pointer-events-auto border border-white/10">
                        Visualizing: <span id="lbl-active-std" class="font-bold text-blue-400">Lapple (1951)</span>
                    </div>
                    <div class="flex items-center gap-2 md:gap-3 bg-black/50 backdrop-blur-md px-3 md:px-4 py-1.5 md:py-2 rounded-xl border border-white/10 pointer-events-auto">
                        <label for="input-FlowSpeed" class="text-white text-[11px] md:text-xs font-bold uppercase tracking-wider">Sim Speed</label>
                        <input type="range" id="input-FlowSpeed" min="0.2" max="3" step="0.1" value="1.0" class="w-20 md:w-24 accent-emerald-500">
                    </div>
                </div>

                <!-- Debug Sync Overlay -->
                <div class="absolute top-2 left-2 md:top-4 md:left-4 z-10 flex flex-col gap-2 pointer-events-auto">
                <button id="debug-sync-toggle" onclick="toggleDebugSyncPanel()" class="px-2.5 py-1.5 bg-black/60 hover:bg-black/75 text-white text-[11px] md:text-xs rounded-lg border border-white/20 font-bold tracking-wide transition-colors">
                    Debug Sync
                </button>
                <div id="debug-sync-panel" class="hidden bg-black/65 text-white/90 rounded-lg border border-white/20 px-2.5 py-2 font-mono text-[11px] md:text-xs min-w-[170px]">
                    <div>Cyclone Y: <span id="debug-cyclone-y">-</span></div>
                    <div>Particle Y: <span id="debug-particle-y">-</span></div>
                    <div>Delta Y: <span id="debug-delta-y">-</span></div>
                </div>
            </div>
                
                <!-- Reset Camera Button -->
                <button onclick="resetCamera()" aria-label="Reset posisi kamera" class="absolute top-2 right-2 md:top-4 md:right-4 p-2 bg-white/20 hover:bg-white/40 backdrop-blur-md rounded-lg text-slate-800 dark:text-white transition-all shadow-lg border border-slate-300 dark:border-slate-600 pointer-events-auto z-10">
                    <svg aria-hidden="true" class="w-4 h-4 md:w-5 md:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
                </button>
            </div>
        </main>
    </div>

    <!-- History Modal -->
    <div id="history-modal" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="history-modal-title" class="fixed inset-0 bg-slate-900/80 backdrop-blur-sm z-50 hidden flex justify-center items-center opacity-0 transition-opacity duration-300 p-4">
        <div class="bg-white dark:bg-slate-900 w-full max-w-5xl rounded-2xl shadow-2xl border border-slate-200 dark:border-slate-800 overflow-hidden flex flex-col max-h-[90vh] transform scale-95 transition-transform duration-300" id="history-modal-content">
            <div class="px-4 md:px-6 py-3 md:py-4 border-b border-slate-200 dark:border-slate-800 flex justify-between items-center bg-slate-50 dark:bg-slate-800/50">
                <h2 id="history-modal-title" class="text-base md:text-lg font-bold flex items-center gap-2">
                    <svg aria-hidden="true" class="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    Calculation History
                </h2>
                <div class="flex gap-2">
                    <button onclick="clearHistory()" class="px-2 md:px-3 py-1 md:py-1.5 text-xs font-bold text-red-600 bg-red-100 dark:bg-red-900/30 rounded-lg hover:bg-red-200 transition-colors">🗑️ Clear All</button>
                    <button onclick="toggleHistoryModal()" aria-label="Tutup modal riwayat" class="p-1 md:p-1.5 text-slate-500 hover:text-slate-800 dark:hover:text-white bg-slate-200 dark:bg-slate-800 rounded-lg"><svg aria-hidden="true" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
                </div>
            </div>
            <div class="p-4 md:p-6 overflow-y-auto flex-grow bg-slate-50 dark:bg-slate-950">
                <div class="overflow-x-auto rounded-xl border border-slate-200 dark:border-slate-800 shadow-sm">
                    <table class="w-full text-xs md:text-sm text-left whitespace-nowrap">
                        <thead class="text-xs text-slate-700 uppercase bg-slate-100 dark:bg-slate-800 dark:text-slate-300">
                            <tr>
                                <th class="px-3 md:px-4 py-2 md:py-3">Mode</th>
                                <th class="px-3 md:px-4 py-2 md:py-3">D (m)</th>
                                <th class="px-3 md:px-4 py-2 md:py-3">Q (m³/s)</th>
                                <th class="px-3 md:px-4 py-2 md:py-3">dp (μm)</th>
                                <th class="px-3 md:px-4 py-2 md:py-3 bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-400">η (%)</th>
                                <th class="px-3 md:px-4 py-2 md:py-3 bg-orange-50 dark:bg-orange-900/20 text-orange-700 dark:text-orange-400">ΔP SL (Pa)</th>
                                <th class="px-3 md:px-4 py-2 md:py-3 text-center">Aksi</th>
                            </tr>
                        </thead>
                        <tbody id="history-table-body" class="divide-y divide-slate-200 dark:divide-slate-800">
                            <!-- Rows injected by JS -->
                        </tbody>
                    </table>
                </div>
                <div id="history-empty" class="text-center py-10 text-slate-500 hidden">
                    <p>Belum ada perhitungan yang disimpan.</p>
                </div>
            </div>
        </div>
    </div>

    <div id="offline-banner" class="hidden fixed inset-x-0 top-14 sm:top-auto sm:bottom-0 z-30 bg-amber-600 text-white text-sm font-semibold px-4 py-2 text-center shadow-lg">
        ⚡ Mode Offline - Data tetap tersimpan lokal
    </div>

    <div id="update-banner" class="hidden fixed top-16 right-4 z-50 bg-blue-600 text-white text-sm font-semibold px-4 py-3 rounded-xl shadow-xl border border-blue-500/50">
        <div class="flex items-center gap-3">
            <span>🔄 Update tersedia</span>
            <button onclick="applyUpdate()" class="px-3 py-1 text-xs font-bold rounded-md bg-white text-blue-700 hover:bg-blue-100 transition-colors">Reload</button>
        </div>
    </div>

    <script>
        // --- 1. STATE & RATIOS ---
        let appMode = 'standard'; 
        let calcHistory = [];
        let deferredInstallPrompt = null;
        let waitingServiceWorker = null;
        const STORAGE_KEYS = { history: 'cycloneHistory', state: 'cycloneStateV1' };
        const STORAGE_DB = { name: 'cycloneProStorage', version: 1, store: 'kv' };
        let dbPromise = null;
        let stateSaveTimer = null;
        const FORM_FIELD_IDS = [
            'geom-D', 'geom-h', 'geom-a', 'geom-b', 'geom-De', 'geom-S', 'geom-H', 'geom-B',
            'phys-Q', 'phys-T', 'phys-RhoP', 'phys-Dp', 'phys-Mu', 'phys-K', 'std-fixed-var', 'input-FlowSpeed'
        ];
        
        const standardRatios = {
            'lapple': { D: 1, a: 0.5, b: 0.25, De: 0.5, S: 0.625, h: 2.0, H: 4.0, B: 0.25 },
            'stairmand_he': { D: 1, a: 0.5, b: 0.2, De: 0.5, S: 0.5, h: 1.5, H: 4.0, B: 0.375 },
            'stairmand_ht': { D: 1, a: 0.75, b: 0.375, De: 0.75, S: 0.875, h: 1.5, H: 4.0, B: 0.375 },
            'swift_he': { D: 1, a: 0.44, b: 0.21, De: 0.4, S: 0.5, h: 1.4, H: 3.9, B: 0.4 }
        };

        // PENCEGAHAN ERROR NaN PADA THREE.JS
        // Mengamankan nilai input yang kosong atau bernilai minus agar tidak merusak geometri 3D
        const getVal = (id) => {
            const val = parseFloat(document.getElementById(id).value);
            if (isNaN(val)) return 0.001; 
            if (id === 'geom-S') return Math.max(0, val); 
            return Math.max(0.001, val); 
        };

        const readLocalStorageJSON = (key, fallbackValue) => {
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return { found: false, value: fallbackValue };
                return { found: true, value: JSON.parse(raw) };
            } catch (error) {
                console.warn('Gagal membaca data lokal:', error);
                return { found: false, value: fallbackValue };
            }
        };

        const writeLocalStorageJSON = (key, value) => {
            try {
                localStorage.setItem(key, JSON.stringify(value));
                return true;
            } catch (error) {
                console.warn('Gagal menyimpan data lokal:', error);
                return false;
            }
        };

        const removeLocalStorageKey = (key) => {
            try {
                localStorage.removeItem(key);
                return true;
            } catch (error) {
                console.warn('Gagal menghapus data lokal:', error);
                return false;
            }
        };

        function openStorageDB() {
            if (dbPromise) return dbPromise;
            if (typeof window === 'undefined' || !('indexedDB' in window)) return Promise.resolve(null);

            dbPromise = new Promise((resolve) => {
                const request = window.indexedDB.open(STORAGE_DB.name, STORAGE_DB.version);

                request.onupgradeneeded = () => {
                    const db = request.result;
                    if (!db.objectStoreNames.contains(STORAGE_DB.store)) {
                        db.createObjectStore(STORAGE_DB.store);
                    }
                };

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => {
                    console.warn('IndexedDB tidak tersedia, fallback ke localStorage.');
                    resolve(null);
                };
            });

            return dbPromise;
        }

        async function idbRead(key) {
            const db = await openStorageDB();
            if (!db) return { found: false, value: null };

            return new Promise((resolve) => {
                try {
                    const tx = db.transaction(STORAGE_DB.store, 'readonly');
                    const req = tx.objectStore(STORAGE_DB.store).get(key);
                    req.onsuccess = () => resolve({ found: req.result !== undefined, value: req.result });
                    req.onerror = () => resolve({ found: false, value: null });
                } catch (_error) {
                    resolve({ found: false, value: null });
                }
            });
        }

        async function idbWrite(key, value) {
            const db = await openStorageDB();
            if (!db) return false;

            return new Promise((resolve) => {
                try {
                    const tx = db.transaction(STORAGE_DB.store, 'readwrite');
                    tx.objectStore(STORAGE_DB.store).put(value, key);
                    tx.oncomplete = () => resolve(true);
                    tx.onerror = () => resolve(false);
                } catch (_error) {
                    resolve(false);
                }
            });
        }

        async function idbDelete(key) {
            const db = await openStorageDB();
            if (!db) return false;

            return new Promise((resolve) => {
                try {
                    const tx = db.transaction(STORAGE_DB.store, 'readwrite');
                    tx.objectStore(STORAGE_DB.store).delete(key);
                    tx.oncomplete = () => resolve(true);
                    tx.onerror = () => resolve(false);
                } catch (_error) {
                    resolve(false);
                }
            });
        }

        async function loadPersistedValue(key, fallbackValue) {
            const fromIDB = await idbRead(key);
            if (fromIDB.found) return fromIDB.value;

            const legacy = readLocalStorageJSON(key, fallbackValue);
            if (legacy.found) {
                await idbWrite(key, legacy.value);
                removeLocalStorageKey(key);
                return legacy.value;
            }

            return fallbackValue;
        }

        async function savePersistedValue(key, value) {
            const savedToIDB = await idbWrite(key, value);
            if (savedToIDB) {
                removeLocalStorageKey(key);
                return true;
            }
            return writeLocalStorageJSON(key, value);
        }

        async function removePersistedValue(key) {
            const removedFromIDB = await idbDelete(key);
            removeLocalStorageKey(key);
            return removedFromIDB;
        }

        function collectCurrentState() {
            const formValues = {};
            FORM_FIELD_IDS.forEach((id) => {
                const element = document.getElementById(id);
                if (element) formValues[id] = element.value;
            });
            return {
                mode: appMode,
                standardType: document.getElementById('std-type').value,
                theme: isDarkMode() ? 'dark' : 'light',
                form: formValues,
                updatedAt: Date.now()
            };
        }

        function scheduleSaveAppState() {
            if (suspendStatePersistence) return;
            clearTimeout(stateSaveTimer);
            stateSaveTimer = setTimeout(() => {
                saveAppState();
            }, 250);
        }

        async function saveAppState() {
            await savePersistedValue(STORAGE_KEYS.state, collectCurrentState());
        }

        function applyStateObject(savedState) {
            if (!savedState || typeof savedState !== 'object') return false;

            if (savedState.theme === 'light') document.documentElement.classList.remove('dark');
            if (savedState.theme === 'dark') document.documentElement.classList.add('dark');

            const stdTypeElement = document.getElementById('std-type');
            if (savedState.standardType && Array.from(stdTypeElement.options).some((opt) => opt.value === savedState.standardType)) {
                stdTypeElement.value = savedState.standardType;
            }

            if (savedState.form && typeof savedState.form === 'object') {
                FORM_FIELD_IDS.forEach((id) => {
                    const element = document.getElementById(id);
                    const value = savedState.form[id];
                    if (element && value !== undefined && value !== null) element.value = value;
                });
            }

            setMode(savedState.mode === 'manual' ? 'manual' : 'standard');
            return true;
        }

        async function applySavedState() {
            const savedState = await loadPersistedValue(STORAGE_KEYS.state, null);
            return applyStateObject(savedState);
        }

        // --- 2. UI LOGIC ---
        function setMode(mode) {
            appMode = mode;
            const tabStd = document.getElementById('tab-standard');
            const tabMan = document.getElementById('tab-manual');
            const secStd = document.getElementById('section-standard');

            if (mode === 'standard') {
                tabStd.className = "flex-1 py-2 text-xs md:text-sm font-bold rounded-md bg-blue-100 dark:bg-blue-900/40 text-blue-700 dark:text-blue-400 transition-colors";
                tabMan.className = "flex-1 py-2 text-xs md:text-sm font-bold rounded-md bg-transparent text-slate-500 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors";
                secStd.style.display = 'block';
                applyStandardRatios();
            } else {
                tabMan.className = "flex-1 py-2 text-xs md:text-sm font-bold rounded-md bg-blue-100 dark:bg-blue-900/40 text-blue-700 dark:text-blue-400 transition-colors";
                tabStd.className = "flex-1 py-2 text-xs md:text-sm font-bold rounded-md bg-transparent text-slate-500 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors";
                secStd.style.display = 'none';

                const allVars = ['D', 'a', 'b', 'De', 'S', 'h', 'H', 'B'];
                allVars.forEach((v) => {
                    const inputEl = document.getElementById('geom-' + v);
                    if (!inputEl) return;
                    inputEl.disabled = false;
                    inputEl.classList.remove('text-blue-600', 'dark:text-blue-400', 'font-bold');
                });
                document.getElementById('lbl-active-std').innerText = "Manual Geometry";
                triggerRecalc();
            }
        }

        function applyStandardRatios() {
            if (appMode !== 'standard') return;
            const stdKey = document.getElementById('std-type').value;
            const fixedVarKey = document.getElementById('std-fixed-var').value;
            const ratios = standardRatios[stdKey];
            if (!ratios || !ratios[fixedVarKey]) return;

            const fixedInput = document.getElementById('geom-' + fixedVarKey);
            if (!fixedInput) return;
            const fixedVal = Math.max(0.001, parseFloat(fixedInput.value) || 0.001);
            const baseD = fixedVal / ratios[fixedVarKey];

            const allVars = ['D', 'a', 'b', 'De', 'S', 'h', 'H', 'B'];
            allVars.forEach((v) => {
                const inputEl = document.getElementById('geom-' + v);
                if (!inputEl) return;

                if (v !== fixedVarKey) {
                    inputEl.value = (baseD * ratios[v]).toFixed(3);
                    inputEl.disabled = true;
                    inputEl.classList.remove('text-blue-600', 'dark:text-blue-400', 'font-bold');
                } else {
                    inputEl.disabled = false;
                    inputEl.classList.add('text-blue-600', 'dark:text-blue-400', 'font-bold');
                }
            });

            const selectEl = document.getElementById('std-type');
            document.getElementById('lbl-active-std').innerText = selectEl.options[selectEl.selectedIndex].text;

            triggerRecalc(true);
        }

        function triggerRecalc(skipRatios = false) {
            if (appMode === 'standard' && !skipRatios) {
                const target = (typeof window !== 'undefined' && window.event && window.event.target) ? window.event.target : null;
                const fixedVarKey = document.getElementById('std-fixed-var').value;
                if (target && target.id === ('geom-' + fixedVarKey)) {
                    applyStandardRatios();
                    return;
                }
            }
            calculatePhysics();
            if (is3DReady) {
                updateCycloneModel();
                initParticles();
            }
            scheduleSaveAppState();
        }

        // --- 3. PHYSICS & MATH ---
        function calculatePhysics() {
            const D = getVal('geom-D');
            const a = getVal('geom-a');
            const b = getVal('geom-b');
            const De = getVal('geom-De');
            const S = getVal('geom-S');
            const h_cyl = getVal('geom-h');
            const H = getVal('geom-H');
            const B = getVal('geom-B');
            const Q = getVal('phys-Q');
            const T = getVal('phys-T');
            const rho_p = getVal('phys-RhoP');
            const dp_um = getVal('phys-Dp');
            const mu_x10 = getVal('phys-Mu');
            const K = getVal('phys-K');

            const mu = mu_x10 * 1e-5;
            const rho_air = 1.293 * (273 / Math.max(T, 1));
            const dp = dp_um * 1e-6;
            const n = 0.7;

            const Vi = Q / Math.max(0.0001, (a * b));

            const Ne = (1 / Math.max(a, 0.0001)) * (h_cyl + Math.max(0.001, H - h_cyl) / 2);
            const d50_m = Math.sqrt((9 * mu * b) / Math.max(0.0000001, (2 * Math.PI * Ne * Vi * (rho_p - rho_air))));
            const d50_um = d50_m * 1e6;

            const l = 2.3 * De * Math.pow((D * D) / Math.max(0.0001, (a * b)), 1 / 3);
            const d_cone = D - (D - B) * ((S + l - h_cyl) / Math.max(0.001, H - h_cyl));
            const C = ((Math.PI * D * D) / Math.max(0.0001, (a * b))) * (
                2 * (1 - Math.pow(De / D, 2)) * (S / D - a / (2 * D)) +
                (1 / 3) * ((S + l - h_cyl) / D) * (1 + d_cone / D + Math.pow(d_cone / D, 2)) +
                h_cyl / D - Math.pow(De / D, 2) * (l / D) - S / D
            );

            const CP = Math.pow(Math.max(0.0000001, (C * D * D / Math.max(0.0001, (a * b))) * (Q / Math.max(0.0001, Math.pow(D, 3))) * (n + 1)), 1 / (2 * n + 2));
            const SP = Math.pow(Math.max(0.0000001, (rho_p * dp * dp) / Math.max(0.0000001, (18 * mu))), 1 / (2 * n + 2));
            const efficiency = (1 - Math.exp(-2 * CP * SP)) * 100;

            const Pdyn = 0.5 * rho_air * Vi * Vi;

            const DH_SL = K * (a * b) / Math.max(0.0001, (De * De));
            const DP_SL = DH_SL * Pdyn;

            const alpha = 1 - 1.2 * (b / Math.max(0.0001, D));
            const lambda = 0.02;
            const ratio_barth = ((De / 2) * (Math.max(0.001, D - b)) * Math.PI) / ((2 * a * b * alpha) + ((H - S) * Math.max(0.001, D - b) * Math.PI * lambda));
            const denominator_barth = Math.max(0.0001, 1 - ratio_barth * (H - S) * (2 / Math.max(De, 0.0001)) * lambda);
            const epsilon_e = (De / D) * ((1 / Math.pow(denominator_barth, 2)) - 1);
            const epsilon_i = (4.4 / Math.pow(Math.max(ratio_barth, 0.0001), 2 / 3)) + 1;
            const DH_Barth = Math.pow(ratio_barth, 2) * Math.pow((4 * a * b) / Math.max(0.0001, (Math.PI * De * De)), 2) * (epsilon_e + epsilon_i);
            const DP_Barth = DH_Barth * Pdyn;

            const Area = (Math.PI / 4) * (D * D - De * De) +
                Math.PI * D * h_cyl +
                Math.PI * De * S +
                (Math.PI / 2) * (D + B) * Math.sqrt((H - h_cyl) * (H - h_cyl) + ((D - B) / 2) * ((D - B) / 2));
            const G_factor = 0.005;
            const term1_stairmand = Math.sqrt(De / (2 * Math.max(0.001, D - b)));
            const term2_stairmand = Math.sqrt((De / (2 * Math.max(0.001, D - b))) + (4 * G_factor * Area) / Math.max(0.0001, (a * b)));
            const denominator_phi = Math.max(0.0001, (2 * G_factor * Area) / Math.max(0.0001, (a * b)));
            const phi = (-term1_stairmand + term2_stairmand) / denominator_phi;
            const DH_Stairmand = 1 + 2 * phi * phi * ((2 * Math.max(0.001, D - b) / Math.max(0.001, De)) - 1) + 2 * Math.pow((4 * a * b) / Math.max(0.0001, (Math.PI * De * De)), 2);
            const DP_Stairmand = DH_Stairmand * Pdyn;

            document.getElementById('res-vi').innerText = Vi.toFixed(1) + " m/s";
            document.getElementById('res-d50').innerText = (isNaN(d50_um) ? 0 : d50_um).toFixed(2) + " μm";
            document.getElementById('res-eff').innerText = Math.max(0, Math.min(100, isNaN(efficiency) ? 0 : efficiency)).toFixed(1) + "%";
            document.getElementById('res-dp').innerText = Math.round(isNaN(DP_SL) ? 0 : DP_SL).toLocaleString() + " Pa";

            const barthEl = document.getElementById('res-dp-barth');
            if (barthEl) barthEl.innerText = isNaN(DP_Barth) ? "0 Pa" : Math.round(DP_Barth).toLocaleString() + " Pa";
            const stairmandEl = document.getElementById('res-dp-stairmand');
            if (stairmandEl) stairmandEl.innerText = isNaN(DP_Stairmand) ? "0 Pa" : Math.round(DP_Stairmand).toLocaleString() + " Pa";
        }

        // --- 4. HISTORY SYSTEM ---
        async function loadHistory() {
            const stored = await loadPersistedValue(STORAGE_KEYS.history, []);
            calcHistory = Array.isArray(stored) ? stored : [];
            updateHistoryUI();
        }

        async function saveToHistory() {
            const stdEl = document.getElementById('std-type');
            const modeName = appMode === 'standard' ? stdEl.options[stdEl.selectedIndex].text : 'Manual Input';
            
            const record = {
                id: Date.now(),
                mode: modeName,
                D: getVal('geom-D'), a: getVal('geom-a'), b: getVal('geom-b'),
                De: getVal('geom-De'), S: getVal('geom-S'), h: getVal('geom-h'), H: getVal('geom-H'), B: getVal('geom-B'),
                Q: getVal('phys-Q'), dp: getVal('phys-Dp'), K: getVal('phys-K'),
                eff: document.getElementById('res-eff').innerText,
                dp_res: document.getElementById('res-dp').innerText
            };
            
            calcHistory.unshift(record); 
            if(calcHistory.length > 20) calcHistory.pop(); 
            
            await savePersistedValue(STORAGE_KEYS.history, calcHistory);
            updateHistoryUI();
            await updateStorageEstimate();
            
            const btn = document.querySelector('button[onclick="saveToHistory()"]');
            const ogText = btn.innerHTML;
            btn.innerHTML = 'OK Disimpan!';
            btn.classList.add('bg-green-500');
            setTimeout(() => { btn.innerHTML = ogText; btn.classList.remove('bg-green-500'); }, 1500);
        }

        function updateHistoryUI() {
            document.querySelectorAll('[data-history-count]').forEach((node) => {
                node.innerText = calcHistory.length;
            });
            const tbody = document.getElementById('history-table-body');
            const emptyState = document.getElementById('history-empty');
            
            tbody.innerHTML = '';
            if (calcHistory.length === 0) {
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            calcHistory.forEach((rec, idx) => {
                const tr = document.createElement('tr');
                tr.className = "bg-white dark:bg-slate-900 hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors";
                tr.innerHTML = `
                    <td class="px-3 md:px-4 py-2 md:py-3 font-medium text-slate-900 dark:text-white">${rec.mode}</td>
                    <td class="px-3 md:px-4 py-2 md:py-3">${rec.D}</td>
                    <td class="px-3 md:px-4 py-2 md:py-3">${rec.Q}</td>
                    <td class="px-3 md:px-4 py-2 md:py-3">${rec.dp}</td>
                    <td class="px-3 md:px-4 py-2 md:py-3 font-bold text-blue-600 dark:text-blue-400">${rec.eff}</td>
                    <td class="px-3 md:px-4 py-2 md:py-3 font-bold text-orange-600 dark:text-orange-400">${rec.dp_res}</td>
                    <td class="px-3 md:px-4 py-2 md:py-3 text-center">
                        <button onclick="loadRecord(${idx})" class="text-xs bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400 px-2 py-1 rounded hover:bg-blue-200">Load</button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        async function clearHistory() {
            if(confirm("Hapus semua riwayat perhitungan?")) {
                calcHistory = [];
                await removePersistedValue(STORAGE_KEYS.history);
                updateHistoryUI();
                await saveAppState();
                await updateStorageEstimate();
            }
        }

        async function exportBackup() {
            await saveAppState();

            const backupPayload = {
                app: 'Cyclone Separator Pro',
                version: 1,
                exportedAt: new Date().toISOString(),
                state: collectCurrentState(),
                history: calcHistory
            };

            const blob = new Blob([JSON.stringify(backupPayload, null, 2)], { type: 'application/json' });
            const fileUrl = URL.createObjectURL(blob);
            const anchor = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            anchor.href = fileUrl;
            anchor.download = `cyclone-backup-${timestamp}.json`;
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
            URL.revokeObjectURL(fileUrl);
        }

        async function importBackupFromFile(event) {
            const input = event.target;
            const file = input && input.files ? input.files[0] : null;
            if (!file) return;

            try {
                const text = await file.text();
                const parsed = JSON.parse(text);

                if (!parsed || typeof parsed !== 'object') throw new Error('Format backup tidak valid');

                const incomingHistory = Array.isArray(parsed.history) ? parsed.history : [];
                calcHistory = incomingHistory.slice(0, 20);
                updateHistoryUI();
                await savePersistedValue(STORAGE_KEYS.history, calcHistory);

                if (parsed.state && typeof parsed.state === 'object') {
                    applyStateObject(parsed.state);
                    await savePersistedValue(STORAGE_KEYS.state, collectCurrentState());
                } else {
                    triggerRecalc();
                }
                await updateStorageEstimate();

                alert('Backup berhasil diimport.');
            } catch (error) {
                console.warn('Import backup gagal:', error);
                alert('Import gagal. Pastikan file backup JSON valid.');
            } finally {
                if (input) input.value = '';
            }
        }

        function loadRecord(idx) {
            const rec = calcHistory[idx];
            setMode('manual');
            document.getElementById('geom-D').value = rec.D;
            document.getElementById('geom-a').value = rec.a;
            document.getElementById('geom-b').value = rec.b;
            document.getElementById('geom-De').value = rec.De;
            document.getElementById('geom-S').value = rec.S !== undefined ? rec.S : document.getElementById('geom-S').value;
            document.getElementById('geom-h').value = rec.h;
            document.getElementById('geom-H').value = rec.H;
            document.getElementById('geom-B').value = rec.B !== undefined ? rec.B : document.getElementById('geom-B').value;
            document.getElementById('phys-Q').value = rec.Q;
            document.getElementById('phys-Dp').value = rec.dp;
            if (rec.K !== undefined) document.getElementById('phys-K').value = rec.K;
            triggerRecalc();
            toggleHistoryModal();
        }

        function toggleHistoryModal() {
            toggleMobileActionMenu(false);
            const modal = document.getElementById('history-modal');
            const content = document.getElementById('history-modal-content');
            if (modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                modal.setAttribute('aria-hidden', 'false');
                setTimeout(() => {
                    modal.classList.remove('opacity-0');
                    content.classList.remove('scale-95');
                }, 10);
            } else {
                modal.classList.add('opacity-0');
                content.classList.add('scale-95');
                modal.setAttribute('aria-hidden', 'true');
                setTimeout(() => modal.classList.add('hidden'), 300);
            }
        }

        // --- 5. THREE.JS IMPLEMENTATION ---
        let scene, camera, renderer, controls, cycloneGroup, particleGroup;
        let particlesHeavy, particlesLight;
        let heavyData = [], lightData = [];
        let debugSyncEnabled = false;
        let lastDebugUpdateTs = 0;
        let perfProfile = null;
        let lastFrameTime = 0;
        let is3DReady = false;
        let suspendStatePersistence = true;
        let threeLoaderPromise = null;

        function isDarkMode() { return document.documentElement.classList.contains('dark'); }
        function toggleTheme() {
            document.documentElement.classList.toggle('dark');
            if (is3DReady) {
                updateCycloneModel();
                initParticles();
            }
            scheduleSaveAppState();
        }

        function getPerformanceProfile() {
            const cores = navigator.hardwareConcurrency || 4;
            const memory = navigator.deviceMemory || 4;
            const isVeryLowEnd = cores <= 2 || memory <= 2;
            const isLowEnd = isVeryLowEnd || cores <= 4 || memory <= 3;
            return {
                lowEnd: isLowEnd,
                veryLowEnd: isVeryLowEnd,
                antialias: !isLowEnd,
                pixelRatioCap: isVeryLowEnd ? 1 : 1.5,
                particleCount: isVeryLowEnd ? 500 : isLowEnd ? 1000 : 2500,
                geometrySegments: isLowEnd ? 24 : 48,
                frameIntervalMs: isLowEnd ? (1000 / 30) : (1000 / 60)
            };
        }

        function ensurePerformanceProfile() {
            if (!perfProfile) perfProfile = getPerformanceProfile();
            return perfProfile;
        }

        function runIdleTask(task, timeoutMs = 1500) {
            const runner = () => Promise.resolve().then(task).catch((error) => {
                console.warn('Deferred task gagal:', error);
            });

            if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {
                window.requestIdleCallback(runner, { timeout: timeoutMs });
                return;
            }
            setTimeout(runner, 0);
        }

        function runTaskAfterFirstPaint(task, timeoutMs = 1500) {
            requestAnimationFrame(() => runIdleTask(task, timeoutMs));
        }

        function loadExternalScript(src) {
            return new Promise((resolve, reject) => {
                const existing = document.querySelector(`script[src="${src}"]`);
                if (existing) {
                    if (existing.dataset.loaded === 'true') {
                        resolve();
                        return;
                    }
                    existing.addEventListener('load', () => resolve(), { once: true });
                    existing.addEventListener('error', () => reject(new Error(`Gagal memuat ${src}`)), { once: true });
                    return;
                }

                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.dataset.loaded = 'false';
                script.addEventListener('load', () => {
                    script.dataset.loaded = 'true';
                    resolve();
                }, { once: true });
                script.addEventListener('error', () => reject(new Error(`Gagal memuat ${src}`)), { once: true });
                document.head.appendChild(script);
            });
        }

        async function ensureThreeLibrariesLoaded() {
            if (typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') return;
            if (!threeLoaderPromise) {
                threeLoaderPromise = (async () => {
                    await loadExternalScript('./vendor/three.min.js');
                    await loadExternalScript('./vendor/OrbitControls.js');
                })();
            }
            await threeLoaderPromise;
        }

        function setupConnectionBanner() {
            const banner = document.getElementById('offline-banner');
            if (!banner) return;

            const updateBanner = () => {
                banner.classList.toggle('hidden', navigator.onLine);
            };

            window.addEventListener('online', updateBanner);
            window.addEventListener('offline', updateBanner);
            updateBanner();
        }

        function toggleMobileActionMenu(forceOpen) {
            const menu = document.getElementById('mobile-action-menu');
            const backdrop = document.getElementById('mobile-action-backdrop');
            const trigger = document.getElementById('mobile-menu-btn');
            if (!menu || !backdrop) return;

            const shouldOpen = typeof forceOpen === 'boolean' ? forceOpen : !menu.classList.contains('is-open');
            menu.classList.toggle('is-open', shouldOpen);
            menu.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
            backdrop.classList.toggle('is-open', shouldOpen);
            document.body.classList.toggle('drawer-open', shouldOpen);
            if (trigger) trigger.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
        }

        function openHistoryFromMobileMenu() {
            toggleMobileActionMenu(false);
            toggleHistoryModal();
        }

        function showUpdateBanner(show) {
            const banner = document.getElementById('update-banner');
            if (!banner) return;
            banner.classList.toggle('hidden', !show);
        }

        function setWaitingServiceWorker(worker) {
            waitingServiceWorker = worker || null;
            showUpdateBanner(Boolean(waitingServiceWorker));
        }

        function applyUpdate() {
            if (!waitingServiceWorker) return;
            showUpdateBanner(false);
            waitingServiceWorker.postMessage({ type: 'SKIP_WAITING' });
        }

        function toggleDebugSyncPanel() {
            debugSyncEnabled = !debugSyncEnabled;
            const panel = document.getElementById('debug-sync-panel');
            const toggle = document.getElementById('debug-sync-toggle');
            if (!panel || !toggle) return;

            panel.classList.toggle('hidden', !debugSyncEnabled);
            toggle.classList.toggle('bg-emerald-700', debugSyncEnabled);
            toggle.classList.toggle('hover:bg-emerald-600', debugSyncEnabled);
            toggle.classList.toggle('border-emerald-300/40', debugSyncEnabled);
            updateDebugSyncPanel(true);
        }

        function updateDebugSyncPanel(force = false) {
            if (!debugSyncEnabled && !force) return;

            const now = performance.now();
            if (!force && now - lastDebugUpdateTs < 120) return;
            lastDebugUpdateTs = now;

            const cycloneY = cycloneGroup ? cycloneGroup.position.y : NaN;
            const particleY = particleGroup ? particleGroup.position.y : NaN;
            const deltaY = cycloneY - particleY;

            const cycloneYNode = document.getElementById('debug-cyclone-y');
            const particleYNode = document.getElementById('debug-particle-y');
            const deltaYNode = document.getElementById('debug-delta-y');
            if (!cycloneYNode || !particleYNode || !deltaYNode) return;

            const fmt = (value) => Number.isFinite(value) ? value.toFixed(4) : '-';
            cycloneYNode.textContent = fmt(cycloneY);
            particleYNode.textContent = fmt(particleY);
            deltaYNode.textContent = fmt(deltaY);
            deltaYNode.className = Math.abs(deltaY) <= 0.001 ? 'text-emerald-300' : 'text-red-300';
        }

        function updateStorageStatus(statusText, isPersistent) {
            const badge = document.getElementById('storage-status');
            if (!badge) return;
            badge.textContent = statusText;
            badge.classList.remove('text-amber-700', 'dark:text-amber-400', 'text-emerald-700', 'dark:text-emerald-400');
            if (isPersistent) {
                badge.classList.add('text-emerald-700', 'dark:text-emerald-400');
            } else {
                badge.classList.add('text-amber-700', 'dark:text-amber-400');
            }
        }

        async function getStorageEngineLabel() {
            const db = await openStorageDB();
            return db ? 'IndexedDB' : 'localStorage';
        }

        function formatStorageBytes(bytes) {
            if (!Number.isFinite(bytes) || bytes < 0) return '0 B';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let value = bytes;
            let unitIdx = 0;
            while (value >= 1024 && unitIdx < units.length - 1) {
                value /= 1024;
                unitIdx += 1;
            }
            return `${value.toFixed(unitIdx === 0 ? 0 : 1)} ${units[unitIdx]}`;
        }

        async function updateStorageEstimate() {
            const note = document.getElementById('storage-quota-note');
            if (!note) return;

            if (!navigator.storage || !navigator.storage.estimate) {
                note.className = 'text-[11px] text-slate-600 dark:text-slate-300';
                note.textContent = 'Pemakaian storage lokal: tidak tersedia di browser ini.';
                return;
            }

            try {
                const estimate = await navigator.storage.estimate();
                const usage = Number(estimate.usage || 0);
                const quota = Number(estimate.quota || 0);

                if (!quota) {
                    note.className = 'text-[11px] text-slate-600 dark:text-slate-300';
                    note.textContent = `Pemakaian storage lokal: ${formatStorageBytes(usage)}`;
                    return;
                }

                const percentage = (usage / quota) * 100;
                note.textContent = `Pemakaian storage lokal: ${formatStorageBytes(usage)} / ${formatStorageBytes(quota)} (${percentage.toFixed(1)}%)`;

                if (percentage >= 80) {
                    note.className = 'text-[11px] text-red-600 dark:text-red-400 font-semibold';
                } else if (percentage >= 60) {
                    note.className = 'text-[11px] text-amber-600 dark:text-amber-400';
                } else {
                    note.className = 'text-[11px] text-slate-600 dark:text-slate-300';
                }
            } catch (error) {
                console.warn('Gagal membaca quota storage:', error);
                note.className = 'text-[11px] text-slate-600 dark:text-slate-300';
                note.textContent = 'Pemakaian storage lokal: gagal dibaca.';
            }
        }

        async function requestPersistentStorage() {
            const storageEngine = await getStorageEngineLabel();
            let statusText = `Storage: ${storageEngine} (standar)`;
            let isPersistent = false;

            if ('storage' in navigator && navigator.storage) {
                try {
                    if (navigator.storage.persisted && await navigator.storage.persisted()) {
                        statusText = `Storage: ${storageEngine} (persisten)`;
                        isPersistent = true;
                    } else if (navigator.storage.persist) {
                        const granted = await navigator.storage.persist();
                        statusText = granted ? `Storage: ${storageEngine} (persisten)` : `Storage: ${storageEngine} (standar)`;
                        isPersistent = granted;
                    }
                } catch (error) {
                    console.warn('Gagal meminta persistent storage:', error);
                }
            }

            updateStorageStatus(statusText, isPersistent);
            await updateStorageEstimate();
        }

        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) return;
            try {
                const registration = await navigator.serviceWorker.register('./sw.js');

                if (registration.waiting) {
                    setWaitingServiceWorker(registration.waiting);
                }

                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    if (!newWorker) return;

                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            setWaitingServiceWorker(newWorker);
                        }
                    });
                });

                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (!event.data) return;
                    if (event.data.type === 'SW_UPDATE_AVAILABLE' && registration.waiting) {
                        setWaitingServiceWorker(registration.waiting);
                    }
                });

                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    window.location.reload();
                });

                setInterval(() => {
                    registration.update().catch(() => {});
                }, 30 * 60 * 1000);
            } catch (error) {
                console.warn('Service worker gagal didaftarkan:', error);
            }
        }

        function isStandaloneMode() {
            return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
        }

        function showInstallHelp() {
            const ua = navigator.userAgent || '';
            const isIOS = /iphone|ipad|ipod/i.test(ua);
            const isAndroid = /android/i.test(ua);
            const isDesktop = !isIOS && !isAndroid;

            if (isIOS) {
                alert('Install di iPhone/iPad: buka menu Share di Safari, lalu pilih "Add to Home Screen".');
                return;
            }

            if (isAndroid) {
                alert('Install di Android: buka menu browser (⋮) lalu pilih "Install app" atau "Add to Home screen".');
                return;
            }

            if (isDesktop) {
                alert('Install di Desktop: klik ikon install di address bar browser, atau buka menu browser lalu pilih "Install app".');
                return;
            }

            alert('Install app via menu browser: "Install app" / "Add to Home screen".');
        }

        function setupInstallPrompt() {
            const installButtons = Array.from(document.querySelectorAll('[data-install-app]'));
            if (installButtons.length === 0) return;

            const setInstalledState = (installed) => {
                installButtons.forEach((button) => {
                    if (installed) {
                        button.textContent = 'Sudah Terpasang';
                        button.disabled = true;
                        button.classList.add('opacity-60', 'cursor-not-allowed');
                    } else {
                        button.textContent = 'Install / Download';
                        button.disabled = false;
                        button.classList.remove('opacity-60', 'cursor-not-allowed');
                    }
                });
            };

            setInstalledState(isStandaloneMode());

            window.addEventListener('beforeinstallprompt', (event) => {
                event.preventDefault();
                deferredInstallPrompt = event;
                if (!isStandaloneMode()) setInstalledState(false);
            });

            installButtons.forEach((installButton) => {
                installButton.addEventListener('click', async () => {
                    toggleMobileActionMenu(false);

                    if (isStandaloneMode()) {
                        setInstalledState(true);
                        return;
                    }

                    if (!deferredInstallPrompt) {
                        showInstallHelp();
                        return;
                    }

                    deferredInstallPrompt.prompt();
                    const choice = await deferredInstallPrompt.userChoice;
                    deferredInstallPrompt = null;

                    if (choice && choice.outcome === 'accepted') {
                        setInstalledState(true);
                    } else {
                        setInstalledState(false);
                    }
                });
            });

            window.addEventListener('appinstalled', () => {
                deferredInstallPrompt = null;
                setInstalledState(true);
                toggleMobileActionMenu(false);
            });
        }

        async function init3D() {
            if (is3DReady) return;
            await ensureThreeLibrariesLoaded();
            const container = document.getElementById('three-container');
            if (!container) throw new Error('Container 3D tidak ditemukan.');
            const perf = ensurePerformanceProfile();
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(6, 2, 8); 

            renderer = new THREE.WebGLRenderer({ antialias: perf.antialias, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, perf.pixelRatioCap));
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1); dirLight.position.set(10, 20, 10); scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x60a5fa, 0.8); backLight.position.set(-10, 10, -10); scene.add(backLight);

            cycloneGroup = new THREE.Group();
            scene.add(cycloneGroup);
            particleGroup = new THREE.Group();
            scene.add(particleGroup);

            window.addEventListener('resize', onWindowResize);

            is3DReady = true;
            calculatePhysics();
            updateCycloneModel();
            initParticles();
            animate();
        }

        function updateCycloneModel() {
            while(cycloneGroup.children.length > 0) cycloneGroup.remove(cycloneGroup.children[0]);

            const D = getVal('geom-D'), a = getVal('geom-a'), b = getVal('geom-b'), De = getVal('geom-De');
            const S = getVal('geom-S'), h = getVal('geom-h'), H = getVal('geom-H'), B = getVal('geom-B');
            const dark = isDarkMode();
            const segs = ensurePerformanceProfile().geometrySegments;
            const segsAlt = Math.max(16, Math.floor(segs * 2 / 3));
            
            const glassColor = dark ? 0x94a3b8 : 0xcbd5e1;
            const lineColor = dark ? 0x3b82f6 : 0x94a3b8;
            
            const glassMat = new THREE.MeshPhongMaterial({ color: glassColor, transparent: true, opacity: 0.15, side: THREE.DoubleSide, shininess: 100, depthWrite: false });
            const lineMat = new THREE.LineBasicMaterial({ color: lineColor, transparent: true, opacity: 0.3 });

            function addPart(geometry, yPos, xPos = 0, zPos = 0) {
                const mesh = new THREE.Mesh(geometry, glassMat);
                mesh.position.set(xPos, yPos, zPos);
                mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geometry), lineMat));
                cycloneGroup.add(mesh);
                return mesh;
            }

            addPart(new THREE.CylinderGeometry(D/2, D/2, h, segs, 1, true), h/2);
            
            const coneHeight = Math.max(0.001, H - h); 
            addPart(new THREE.CylinderGeometry(D/2, B/2, coneHeight, segs, 1, true), -coneHeight/2);
            
            const dustH = 1.0;
            addPart(new THREE.CylinderGeometry(B/2, B/2, dustH, segsAlt, 1, true), -coneHeight - dustH/2);

            const vfLength = S + 0.5; 
            const vfCenterY = h + 0.25 - S/2;
            addPart(new THREE.CylinderGeometry(De/2, De/2, vfLength, segsAlt, 1, true), vfCenterY);

            const inlet = addPart(new THREE.BoxGeometry(D, a, b), h - a/2);
            inlet.position.set(D/2, h - a/2, 0); 
            
            cycloneGroup.position.y = (coneHeight - h) / 2;
            if (particleGroup) particleGroup.position.y = cycloneGroup.position.y;
            updateDebugSyncPanel(true);
        }

        function initParticles() {
            if (particlesHeavy && particleGroup) particleGroup.remove(particlesHeavy);
            if (particlesLight && particleGroup) particleGroup.remove(particlesLight);
            
            const totalCount = ensurePerformanceProfile().particleCount;
            const effStr = document.getElementById('res-eff').innerText;
            const effVal = parseFloat(effStr.replace('%','')) || 50;
            const heavyCount = Math.floor(totalCount * (effVal / 100));
            const lightCount = totalCount - heavyCount;

            heavyData = []; lightData = [];
            const dark = isDarkMode();

            const createPoints = (count, colorHex, isHeavy) => {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count; i++) resetParticle(i, pos, isHeavy ? 'heavy' : 'light');
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ color: colorHex, size: 0.05, transparent: true, opacity: 0.8, depthWrite: false });
                const pts = new THREE.Points(geo, mat);
                particleGroup.add(pts);
                return pts;
            };

            particlesHeavy = createPoints(heavyCount, dark ? 0xfacc15 : 0xd97706, true);
            particlesLight = createPoints(lightCount, dark ? 0xffffff : 0x2563eb, false);
        }

        function resetParticle(i, positions, type) {
            const D = getVal('geom-D'), h = getVal('geom-h'), a = getVal('geom-a'), b = getVal('geom-b');
            const startAngle = 0; 
            const r = (D/2) - (Math.random() * b * 0.8); 
            
            positions[i*3] = r * Math.cos(startAngle) + (D/2); 
            positions[i*3 + 1] = h - (Math.random() * a); 
            positions[i*3 + 2] = r * Math.sin(startAngle); 

            const dataObj = {
                angle: startAngle, radius: r, targetRadius: r,
                vSpeed: (0.02 + Math.random() * 0.03), rotSpeed: (0.05 + Math.random() * 0.05),
                phase: 'entering', randomOffset: (Math.random() - 0.5) * 0.1
            };
            if (type === 'heavy') heavyData[i] = dataObj; else lightData[i] = dataObj;
        }

        function updateParticlesLogic() {
            if (!particlesHeavy || !particlesLight) return;
            
            const D = getVal('geom-D'), h = getVal('geom-h'), H = getVal('geom-H');
            const B = getVal('geom-B');
            const De = getVal('geom-De'), coneHeight = Math.max(0.001, H - h);
            const speedMult = parseFloat(document.getElementById('input-FlowSpeed').value) || 1.0;

            const processParticles = (pts, dataArr, isHeavy) => {
                const pos = pts.geometry.attributes.position.array;
                for (let i = 0; i < dataArr.length; i++) {
                    let p = dataArr[i];
                    let x = pos[i*3], y = pos[i*3+1], z = pos[i*3+2];

                    if (p.phase === 'entering') {
                        pos[i*3] -= 0.1 * speedMult; 
                        if (pos[i*3] <= p.radius) { 
                            p.phase = 'outer_vortex'; 
                            // PENGAMAN MATH.ACOS() : Cegah nilai melebihi 1 atau kurang dari -1
                            let ratioVal = pos[i*3] / p.radius;
                            ratioVal = Math.max(-1, Math.min(1, ratioVal));
                            p.angle = Math.acos(ratioVal) || 0; 
                        }
                    } else if (p.phase === 'outer_vortex') {
                        p.angle += p.rotSpeed * speedMult;
                        y -= p.vSpeed * speedMult;
                        let maxR = D/2 - 0.02;
                        
                        if (y < 0) { 
                            if (y >= -coneHeight) {
                                const progress = Math.abs(y) / coneHeight;
                                maxR = (D/2 * (1 - progress)) + (B/2 * progress) - 0.02;
                            } else {
                                // Jika partikel melompati batas cone dalam 1 frame, tetap pakai radius outlet bawah.
                                maxR = B/2 - 0.02;
                            }
                        }
                        maxR = Math.max(0.001, maxR);
                        
                        if(isHeavy) {
                            p.radius += (maxR - p.radius) * Math.min(1, 0.2 * speedMult);
                            // Hard clamp supaya radius tidak pernah menembus dinding.
                            p.radius = Math.min(Math.max(0.001, p.radius), maxR);
                            if (y < -coneHeight + 0.1) p.phase = 'dust_drop';
                        } else {
                            const targetOuterR = Math.max(0.001, maxR * 0.8);
                            p.radius += (targetOuterR - p.radius) * Math.min(1, 0.1 * speedMult);
                            p.radius = Math.min(Math.max(0.001, p.radius), Math.max(0.001, maxR - 0.02));
                            const turnaround = -(coneHeight * 0.5) - (Math.random() * (coneHeight * 0.4));
                            if (y < turnaround) {
                                p.phase = 'inner_vortex';
                                p.vSpeed = Math.abs(p.vSpeed) * 1.5; 
                                p.rotSpeed *= 2; 
                            }
                        }

                        pos[i*3] = p.radius * Math.cos(p.angle);
                        pos[i*3+1] = y;
                        pos[i*3+2] = p.radius * Math.sin(p.angle);
                        
                    } else if (p.phase === 'dust_drop' && isHeavy) {
                        y -= (p.vSpeed * 2) * speedMult; 
                        p.angle += p.rotSpeed * 0.5 * speedMult;

                        // Transisi radius lebih halus saat masuk pipa bawah.
                        const targetDustR = Math.max(0.001, B/2 - 0.02);
                        p.radius += (targetDustR - p.radius) * Math.min(1, 0.3 * speedMult);
                        p.radius = Math.min(Math.max(0.001, p.radius), targetDustR);

                        pos[i*3] = p.radius * Math.cos(p.angle);
                        pos[i*3+1] = y;
                        pos[i*3+2] = p.radius * Math.sin(p.angle);
                        if (y < -coneHeight - 1.0) resetParticle(i, pos, 'heavy');
                    } else if (p.phase === 'inner_vortex' && !isHeavy) {
                        p.angle += p.rotSpeed * speedMult;
                        y += p.vSpeed * speedMult;
                        const innerR = (De/2) * 0.7 * (1 + p.randomOffset);
                        const currentR = Math.sqrt(x*x + z*z);
                        const newR = currentR + (innerR - currentR) * Math.min(1, 0.1 * speedMult);

                        pos[i*3] = newR * Math.cos(p.angle);
                        pos[i*3+1] = y;
                        pos[i*3+2] = newR * Math.sin(p.angle);
                        if (y > h + 1.0) resetParticle(i, pos, 'light');
                    }
                }
                pts.geometry.attributes.position.needsUpdate = true;
            };

            processParticles(particlesHeavy, heavyData, true);
            processParticles(particlesLight, lightData, false);
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const perf = ensurePerformanceProfile();
            if (now - lastFrameTime < perf.frameIntervalMs) return;
            lastFrameTime = now;
            controls.update();
            updateParticlesLogic();
            updateDebugSyncPanel();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            if (!is3DReady || !camera || !renderer) return;
            const container = document.getElementById('three-container');
            const wrapper = document.querySelector('.canvas-wrapper');
            // Penyesuaian aspek rasio ulang pada resize screen
            if(container && wrapper) {
                camera.aspect = wrapper.clientWidth / wrapper.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, ensurePerformanceProfile().pixelRatioCap));
            }
        }

        function resetCamera() {
            if (!is3DReady || !camera || !controls) return;
            camera.position.set(6, 2, 8);
            controls.target.set(0, 0, 0);
        }

        async function restorePersistedData() {
            try {
                await loadHistory();
                const hasSavedState = await applySavedState();
                if (!hasSavedState) {
                    calculatePhysics();
                }
            } finally {
                suspendStatePersistence = false;
                if (is3DReady) {
                    calculatePhysics();
                    updateCycloneModel();
                    initParticles();
                }
                scheduleSaveAppState();
            }
        }

        async function bootstrapApp() {
            setupInstallPrompt();
            setupConnectionBanner();
            window.addEventListener('resize', () => {
                if (window.innerWidth >= 640) toggleMobileActionMenu(false);
            });
            window.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') toggleMobileActionMenu(false);
            });
            // Render UI secepat mungkin tanpa beban 3D/IndexedDB.
            setMode('standard');
            registerServiceWorker();

            // Tugas berat dipindah ke idle agar TBT/LCP lebih baik.
            runTaskAfterFirstPaint(() => init3D(), 2000);
            runTaskAfterFirstPaint(() => restorePersistedData(), 2500);
            runIdleTask(() => requestPersistentStorage(), 4000);
        }

        window.onload = bootstrapApp;

    </script>
</body>
</html>

